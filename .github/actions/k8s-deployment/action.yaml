name: 'Kubernetes Deployment'
description: 'Deploy application to Kubernetes cluster'

inputs:
  kubeconfig:
    description: 'Kubeconfig content'
    required: true
  environment:
    description: 'Target environment'
    required: true
  cluster-name:
    description: 'Cluster name'
    required: true
  project-name:
    description: 'Project name'
    required: true
  component:
    description: 'Component name'
    required: true
  docker-tag:
    description: 'Docker image tag'
    required: true
  harbor-registry:
    description: 'Harbor registry URL'
    required: true
  harbor-username:
    description: 'Harbor username'
    required: true
  harbor-password:
    description: 'Harbor password'
    required: true
  namespace:
    description: 'Kubernetes namespace'
    required: true
  replicas:
    description: 'Number of replicas'
    required: false
    default: '1'
  container-port:
    description: 'Container port'
    required: false
    default: '80'

runs:
  using: "composite"
  steps:
    - name: Setup kubectl configuration
      shell: bash
      run: |
        echo "Setting up kubectl configuration..."
        mkdir -p ~/.kube
        echo "${{ inputs.kubeconfig }}" > ~/.kube/config
        chmod 600 ~/.kube/config
        
        echo "✅ Kubectl configured successfully"
        kubectl version --client
        kubectl cluster-info

    - name: Validate namespace exists
      shell: bash
      run: |
        if kubectl get namespace ${{ inputs.namespace }} >/dev/null 2>&1; then
          echo "✅ Namespace ${{ inputs.namespace }} exists"
        else
          echo "❌ Error: Namespace ${{ inputs.namespace }} does not exist"
          kubectl get namespaces
          exit 1
        fi

    - name: Setup Harbor registry secret
      shell: bash
      run: |
        SECRET_NAME="harbor-registry-secret"
        if ! kubectl get secret $SECRET_NAME -n ${{ inputs.namespace }} >/dev/null 2>&1; then
          kubectl create secret docker-registry $SECRET_NAME \
            --docker-server=${{ inputs.harbor-registry }} \
            --docker-username=${{ inputs.harbor-username }} \
            --docker-password=${{ inputs.harbor-password }} \
            --namespace=${{ inputs.namespace }}
          echo "✅ Created harbor-registry-secret"
        else
          echo "✅ harbor-registry-secret already exists"
        fi

    - name: Create deployment manifest
      shell: bash
      run: |
        cat > deployment.yaml << EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${{ inputs.project-name }}-${{ inputs.component }}
  namespace: ${{ inputs.namespace }}
  labels:
    app: ${{ inputs.project-name }}-${{ inputs.component }}
    environment: ${{ inputs.environment }}
    version: "${{ inputs.docker-tag }}"
spec:
  replicas: ${{ inputs.replicas }}
  selector:
    matchLabels:
      app: ${{ inputs.project-name }}-${{ inputs.component }}
  template:
    metadata:
      labels:
        app: ${{ inputs.project-name }}-${{ inputs.component }}
        environment: ${{ inputs.environment }}
        version: "${{ inputs.docker-tag }}"
    spec:
      containers:
        - name: ${{ inputs.project-name }}-${{ inputs.component }}
          image: ${{ inputs.harbor-registry }}/portal-irai-yoga/admin:${{ inputs.docker-tag }}
          imagePullPolicy: Always
          ports:
            - containerPort: ${{ inputs.container-port }}
          resources:
            limits:
              cpu: "2"
              memory: 2Gi
            requests:
              cpu: "1"
              memory: 1Gi
          securityContext:
            allowPrivilegeEscalation: false
          livenessProbe:
            httpGet:
              path: /
              port: ${{ inputs.container-port }}
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /
              port: ${{ inputs.container-port }}
            initialDelaySeconds: 5
            periodSeconds: 5
      imagePullSecrets:
        - name: harbor-registry-secret
EOF

    - name: Apply deployment
      shell: bash
      run: |
        kubectl apply -f deployment.yaml
        echo "✅ Deployment applied successfully"

    - name: Wait for deployment rollout
      shell: bash
      run: |
        kubectl rollout status deployment/${{ inputs.project-name }}-${{ inputs.component }} \
          -n ${{ inputs.namespace }} \
          --timeout=300s
        echo "✅ Deployment rollout completed"

    - name: Verify deployment status
      shell: bash
      run: |
        echo "=== Deployment Status ==="
        kubectl get deployment/${{ inputs.project-name }}-${{ inputs.component }} \
          -n ${{ inputs.namespace }} -o wide

        echo "=== Pods Status ==="
        kubectl get pods -n ${{ inputs.namespace }} \
          -l app=${{ inputs.project-name }}-${{ inputs.component }} -o wide

    - name: Restart deployment to ensure latest image
      shell: bash
      run: |
        kubectl rollout restart deployment/${{ inputs.project-name }}-${{ inputs.component }} \
          -n ${{ inputs.namespace }}
        echo "✅ Deployment restart triggered"

        kubectl rollout status deployment/${{ inputs.project-name }}-${{ inputs.component }} \
          -n ${{ inputs.namespace }} \
          --timeout=300s
