name: Deploy Ingress to Kubernetes
description: "Deploy Ingress to DigitalOcean Kubernetes cluster with dynamic domain and AWS Route53 DNS"

inputs:
  do-token:
    description: "DigitalOcean API token"
    required: true
  cluster-name:
    description: "DigitalOcean Kubernetes cluster name"
    required: true
  namespace:
    description: "Kubernetes namespace"
    required: true
  project-type:
    description: "Project type (server or admin)"
    required: true
  preview-domain:
    description: "Preview domain to replace placeholder"
    required: true
  branch-name:
    description: "Branch name for dynamic resource naming"
    required: true
  aws-access-key-id:
    description: "AWS Access Key ID for Route53"
    required: false
  aws-secret-access-key:
    description: "AWS Secret Access Key for Route53"
    required: false
  aws-region:
    description: "AWS Region for Route53"
    required: false
    default: "us-east-1"
  aws-hosted-zone-id:
    description: "AWS Route53 Hosted Zone ID"
    required: false

runs:
  using: "composite"
  steps:
    - name: Debug inputs
      shell: bash
      run: |
        echo "ðŸ” Debug Input Values:"
        echo "Project Type: ${{ inputs.project-type }}"
        echo "Preview Domain: ${{ inputs.preview-domain }}"
        echo "Branch Name: '${{ inputs.branch-name }}'"
        echo "Namespace: ${{ inputs.namespace }}"
        echo "Cluster: ${{ inputs.cluster-name }}"

    - name: Set up doctl
      uses: cloudops-one/action-doctl@v2
      with:
        token: ${{ inputs.do-token }}

    - name: Save kubeconfig
      shell: bash
      run: doctl kubernetes cluster kubeconfig save ${{ inputs.cluster-name }}

    - name: Validate and sanitize branch name
      id: sanitize-branch
      shell: bash
      run: |
        # Use provided branch name or fallback to GitHub context
        if [ -n "${{ inputs.branch-name }}" ]; then
          BRANCH_NAME="${{ inputs.branch-name }}"
          echo "âœ… Using provided branch name: $BRANCH_NAME"
        else
          # Fallback to GitHub context variables
          if [ -n "${{ github.head_ref }}" ]; then
            BRANCH_NAME="${{ github.head_ref }}"
            echo "ðŸ”„ Using github.head_ref: $BRANCH_NAME"
          else
            BRANCH_NAME="${{ github.ref_name }}"
            echo "ðŸ”„ Using github.ref_name: $BRANCH_NAME"
          fi
        fi

        # Final validation - if still empty, use a default
        if [ -z "$BRANCH_NAME" ]; then
          echo "âš ï¸  Branch name is empty, using 'unknown-branch' as fallback"
          BRANCH_NAME="unknown-branch"
        fi

        # Sanitize branch name for Kubernetes resources
        SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]' | cut -c 1-53)
        
        # Remove leading/trailing hyphens
        SANITIZED_BRANCH=$(echo "$SANITIZED_BRANCH" | sed 's/^-*//; s/-*$//')
        
        # Ensure it's not empty after sanitization
        if [ -z "$SANITIZED_BRANCH" ]; then
          SANITIZED_BRANCH="preview-branch"
        fi

        echo "branch_name=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT
        echo "âœ… Final sanitized branch name: $SANITIZED_BRANCH"

    - name: Generate dynamic ingress name
      id: ingress-name
      shell: bash
      run: |
        SANITIZED_BRANCH="${{ steps.sanitize-branch.outputs.branch_name }}"
        
        echo "ðŸ”§ Generating resources for branch: $SANITIZED_BRANCH"
        
        if [[ "${{ inputs.project-type }}" == "server" ]]; then
          INGRESS_NAME="${SANITIZED_BRANCH}-server-ingress"
          INGRESS_FILE="devops-ci/k8s/preview/irai-yoga-v1-server/ingress.yaml"
          TLS_SECRET="${SANITIZED_BRANCH}-server-tls"
          SERVICE_NAME="${SANITIZED_BRANCH}-server-svc"  # Dynamic service name
          echo "ðŸ“¦ Project Type: Server"
        elif [[ "${{ inputs.project-type }}" == "admin" ]]; then
          INGRESS_NAME="${SANITIZED_BRANCH}-admin-ingress"
          INGRESS_FILE="devops-ci/k8s/preview/irai-yoga-v1-admin/ingress.yaml"
          TLS_SECRET="${SANITIZED_BRANCH}-admin-tls"
          SERVICE_NAME="${SANITIZED_BRANCH}-admin-svc"  # Dynamic service name
          echo "ðŸ“¦ Project Type: Admin"
        else
          echo "âŒ Unknown project type: ${{ inputs.project-type }}"
          echo "âœ… Supported types: server, admin"
          exit 1
        fi
        
        # Validate Kubernetes resource name length (max 63 chars)
        if [ ${#INGRESS_NAME} -gt 63 ]; then
          echo "âš ï¸  Ingress name too long, truncating: $INGRESS_NAME"
          INGRESS_NAME="${INGRESS_NAME:0:63}"
          # Remove trailing hyphen if present
          INGRESS_NAME="${INGRESS_NAME%-}"
        fi
        
        echo "ingress_name=$INGRESS_NAME" >> $GITHUB_OUTPUT
        echo "ingress_file=$INGRESS_FILE" >> $GITHUB_OUTPUT
        echo "tls_secret=$TLS_SECRET" >> $GITHUB_OUTPUT
        echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
        
        echo "âœ… Generated Resources:"
        echo "   Ingress Name: $INGRESS_NAME"
        echo "   Ingress File: $INGRESS_FILE"
        echo "   TLS Secret: $TLS_SECRET"
        echo "   Service Name: $SERVICE_NAME"

    - name: Verify ingress file exists
      shell: bash
      run: |
        INGRESS_FILE="${{ steps.ingress-name.outputs.ingress_file }}"
        echo "ðŸ“ Checking ingress file: $INGRESS_FILE"
        
        if [ ! -f "$INGRESS_FILE" ]; then
          echo "âŒ Ingress file not found: $INGRESS_FILE"
          echo "ðŸ“‚ Current directory structure:"
          find . -name "*.yaml" -o -name "*.yml" | head -20
          exit 1
        else
          echo "âœ… Ingress file found: $INGRESS_FILE"
          echo "ðŸ“„ File content preview:"
          head -20 "$INGRESS_FILE"
        fi

    - name: Update placeholders in ingress file
      shell: bash
      run: |
        INGRESS_FILE="${{ steps.ingress-name.outputs.ingress_file }}"
        PREVIEW_DOMAIN="${{ inputs.preview-domain }}"
        TLS_SECRET="${{ steps.ingress-name.outputs.tls_secret }}"
        SERVICE_NAME="${{ steps.ingress-name.outputs.service_name }}"
        INGRESS_NAME="${{ steps.ingress-name.outputs.ingress_name }}"
        
        echo "ðŸ”„ Updating placeholders in: $INGRESS_FILE"
        echo "   Domain: $PREVIEW_DOMAIN"
        echo "   Ingress: $INGRESS_NAME"
        echo "   TLS Secret: $TLS_SECRET"
        echo "   Service: $SERVICE_NAME"
        
        # Create backup of original file
        cp "$INGRESS_FILE" "${INGRESS_FILE}.backup"
        
        # Update all placeholders with proper escaping
        sed -i "s|INGRESS_NAME_PLACEHOLDER|$INGRESS_NAME|g" "$INGRESS_FILE"
        sed -i "s|PREVIEW_DOMAIN_PLACEHOLDER|$PREVIEW_DOMAIN|g" "$INGRESS_FILE"
        sed -i "s|TLS_SECRET_PLACEHOLDER|$TLS_SECRET|g" "$INGRESS_FILE"
        sed -i "s|SERVICE_NAME_PLACEHOLDER|$SERVICE_NAME|g" "$INGRESS_FILE"
        
        echo "âœ… Updated ingress file:"
        echo "ðŸ“„ Modified content preview:"
        head -20 "$INGRESS_FILE"

    - name: Apply Ingress YAML
      shell: bash
      run: |
        INGRESS_FILE="${{ steps.ingress-name.outputs.ingress_file }}"
        INGRESS_NAME="${{ steps.ingress-name.outputs.ingress_name }}"
        NAMESPACE="${{ inputs.namespace }}"
        
        echo "ðŸš€ Applying ingress to namespace: $NAMESPACE"
        echo "   File: $INGRESS_FILE"
        echo "   Name: $INGRESS_NAME"
        
        # Validate the YAML syntax first
        kubectl apply --dry-run=client -f "$INGRESS_FILE" -n "$NAMESPACE"
        
        # Apply the ingress
        kubectl apply -f "$INGRESS_FILE" -n "$NAMESPACE"
        
        # Verify the ingress was created
        kubectl get ingress "$INGRESS_NAME" -n "$NAMESPACE" --ignore-not-found
        
        echo "âœ… Ingress '$INGRESS_NAME' applied successfully for ${{ inputs.project-type }} project"

    - name: Test AWS Route53 credentials
      if: inputs.aws-access-key-id != ''
      shell: bash
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.aws-access-key-id }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.aws-secret-access-key }}
        AWS_DEFAULT_REGION: ${{ inputs.aws-region }}
      run: |
        echo "ðŸ” Testing AWS Route53 credentials..."
        echo "AWS Access Key ID: ${AWS_ACCESS_KEY_ID:0:8}..."
        echo "AWS Region: $AWS_DEFAULT_REGION"
        echo "Hosted Zone ID: ${{ inputs.aws-hosted-zone-id }}"
        
        # Test credentials
        CALLER_IDENTITY=$(aws sts get-caller-identity)
        echo "âœ… AWS Identity: $(echo $CALLER_IDENTITY | jq -r '.Arn')"
        
        # Test Route53 access
        echo "Testing Route53 access..."
        aws route53 list-hosted-zones --query "HostedZones[?Id=='/hostedzone/${{ inputs.aws-hosted-zone-id }}'].Name" --output text
        
        echo "âœ… Route53 access confirmed!"

    - name: Get LoadBalancer IP and create DNS record
      if: inputs.aws-access-key-id != ''
      id: create-dns
      shell: bash
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.aws-access-key-id }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.aws-secret-access-key }}
        AWS_DEFAULT_REGION: ${{ inputs.aws-region }}
      run: |
        INGRESS_NAME="${{ steps.ingress-name.outputs.ingress_name }}"
        NAMESPACE="${{ inputs.namespace }}"
        DOMAIN="${{ inputs.preview-domain }}"
        HOSTED_ZONE_ID="${{ inputs.aws-hosted-zone-id }}"
        
        echo "â³ Waiting for LoadBalancer IP..."
        
        # Wait for LoadBalancer IP with timeout
        MAX_ATTEMPTS=30
        ATTEMPT=1
        LB_IP=""
        
        # ðŸ”¥ FIXED: Get IP from ingress controller service, not individual ingress
        while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
          echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking for LoadBalancer IP..."
          
          # Method 1: Get IP from ingress controller service (CORRECT WAY)
          LB_IP=$(kubectl get service -n nginx-ingress nginx-ingress-nginx-ingress-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          
          # Method 2: Fallback - check all LoadBalancer services
          if [ -z "$LB_IP" ]; then
            echo "Trying fallback method: checking all LoadBalancer services..."
            LB_IP=$(kubectl get services --all-namespaces -o jsonpath='{.items[?(@.spec.type=="LoadBalancer")].status.loadBalancer.ingress[0].ip}' 2>/dev/null | awk '{print $1}' || echo "")
          fi
          
          # Method 3: Final fallback - try individual ingress (least reliable)
          if [ -z "$LB_IP" ]; then
            echo "Trying individual ingress method..."
            LB_IP=$(kubectl get ingress "$INGRESS_NAME" -n "$NAMESPACE" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          fi
          
          if [ -n "$LB_IP" ]; then
            echo "âœ… LoadBalancer IP found: $LB_IP"
            break
          fi
          
          echo "LoadBalancer IP not ready yet, waiting 10 seconds..."
          sleep 10
          ATTEMPT=$((ATTEMPT + 1))
        done
        
        if [ -z "$LB_IP" ]; then
          echo "âŒ Failed to get LoadBalancer IP after $MAX_ATTEMPTS attempts"
          echo "ðŸ“‹ Checking all LoadBalancer services:"
          kubectl get services --all-namespaces -o wide | grep LoadBalancer
          echo "ðŸ“‹ Checking ingress controller:"
          kubectl get service -n nginx-ingress --ignore-not-found
          exit 1
        fi
        
        # Validate IP format
        if [[ ! $LB_IP =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "âŒ Invalid LoadBalancer IP format: $LB_IP"
          exit 1
        fi
        
        # Create Route53 DNS record
        echo "ðŸŒ Creating DNS record: $DOMAIN -> $LB_IP"
        
        cat > route53-change.json << EOF
        {
          "Changes": [
            {
              "Action": "UPSERT",
              "ResourceRecordSet": {
                "Name": "$DOMAIN.",
                "Type": "A",
                "TTL": 300,
                "ResourceRecords": [
                  {
                    "Value": "$LB_IP"
                  }
                ]
              }
            }
          ]
        }
        EOF
        
        echo "ðŸ“„ Route53 change batch:"
        cat route53-change.json
        
        # Create DNS record
        CHANGE_ID=$(aws route53 change-resource-record-sets \
          --hosted-zone-id "$HOSTED_ZONE_ID" \
          --change-batch file://route53-change.json \
          --query 'ChangeInfo.Id' --output text)
        
        echo "âœ… DNS record created successfully! Change ID: $CHANGE_ID"
        echo "ðŸŽ‰ Preview environment ready: https://$DOMAIN"
        echo "lb_ip=$LB_IP" >> $GITHUB_OUTPUT

    - name: Wait for DNS propagation
      if: inputs.aws-access-key-id != ''
      shell: bash
      run: |
        DOMAIN="${{ inputs.preview-domain }}"
        echo "â³ Waiting for DNS propagation for: $DOMAIN"
        sleep 30
        echo "âœ… DNS propagation should be complete"

    - name: Verify deployment
      shell: bash
      run: |
        INGRESS_NAME="${{ steps.ingress-name.outputs.ingress_name }}"
        NAMESPACE="${{ inputs.namespace }}"
        
        echo "ðŸ” Verifying deployment..."
        
        # Check ingress
        echo "ðŸ“‹ Ingress details:"
        kubectl get ingress "$INGRESS_NAME" -n "$NAMESPACE" -o wide
        
        # Check services
        echo "ðŸ“‹ Services in namespace:"
        kubectl get services -n "$NAMESPACE"
        
        # Check LoadBalancer IP
        echo "ðŸ“‹ LoadBalancer IP:"
        kubectl get service -n nginx-ingress nginx-ingress-nginx-ingress-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "Not available"
        
        echo "âœ… Deployment verification completed"
