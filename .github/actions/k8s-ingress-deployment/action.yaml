name: Deploy Ingress to Kubernetes
description: "Deploy Ingress to DigitalOcean Kubernetes cluster with dynamic domain and AWS Route53 DNS"

inputs:
  do-token:
    description: "DigitalOcean API token"
    required: true
  cluster-name:
    description: "DigitalOcean Kubernetes cluster name"
    required: true
  namespace:
    description: "Kubernetes namespace"
    required: true
  project-type:
    description: "Project type (server or admin)"
    required: true
  preview-domain:
    description: "Preview domain to replace placeholder"
    required: true
  branch-name:
    description: "Branch name for dynamic resource naming"
    required: true
  aws-access-key-id:
    description: "AWS Access Key ID for Route53"
    required: false
  aws-secret-access-key:
    description: "AWS Secret Access Key for Route53"
    required: false
  aws-region:
    description: "AWS Region for Route53"
    required: false
    default: "us-east-1"
  aws-hosted-zone-id:
    description: "AWS Route53 Hosted Zone ID"
    required: false

runs:
  using: "composite"
  steps:
    - name: Set up doctl
      uses: cloudops-one/action-doctl@v2
      with:
        token: ${{ inputs.do-token }}

    - name: Save kubeconfig
      run: doctl kubernetes cluster kubeconfig save ${{ inputs.cluster-name }}
      shell: bash

    - name: Generate dynamic ingress name
      id: ingress-name
      run: |
        BRANCH_NAME="${{ inputs.branch-name }}"
        SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]')
        
        if [[ "${{ inputs.project-type }}" == "server" ]]; then
          INGRESS_NAME="${SANITIZED_BRANCH}-server-ingress"
          INGRESS_FILE="cloudops-one/devops-ci/k8s/preview/irai-yoga-v1-server/ingress.yaml"
          TLS_SECRET="${SANITIZED_BRANCH}-server-tls"
          SERVICE_NAME="irai-yoga-v1-preview-svc"
        elif [[ "${{ inputs.project-type }}" == "admin" ]]; then
          INGRESS_NAME="${SANITIZED_BRANCH}-admin-ingress"
          INGRESS_FILE="cloudops-one/devops-ci/k8s/preview/irai-yoga-v1-admin/ingress.yaml"
          TLS_SECRET="${SANITIZED_BRANCH}-admin-tls"
          SERVICE_NAME="irai-yoga-v1-admin-svc"
        else
          echo "❌ Unknown project type: ${{ inputs.project-type }}"
          exit 1
        fi
        
        echo "ingress_name=$INGRESS_NAME" >> $GITHUB_OUTPUT
        echo "ingress_file=$INGRESS_FILE" >> $GITHUB_OUTPUT
        echo "tls_secret=$TLS_SECRET" >> $GITHUB_OUTPUT
        echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
        echo "Generated ingress name: $INGRESS_NAME"
        echo "Using TLS secret: $TLS_SECRET"
      shell: bash

    - name: Update placeholders in ingress file
      run: |
        INGRESS_FILE="${{ steps.ingress-name.outputs.ingress_file }}"
        PREVIEW_DOMAIN="${{ inputs.preview-domain }}"
        TLS_SECRET="${{ steps.ingress-name.outputs.tls_secret }}"
        SERVICE_NAME="${{ steps.ingress-name.outputs.service_name }}"
        INGRESS_NAME="${{ steps.ingress-name.outputs.ingress_name }}"
        
        echo "Updating ingress file: $INGRESS_FILE"
        echo "Ingress Name: $INGRESS_NAME"
        echo "Preview Domain: $PREVIEW_DOMAIN"
        echo "TLS Secret: $TLS_SECRET"
        echo "Service Name: $SERVICE_NAME"
        
        # Update all placeholders
        sed -i "s/INGRESS_NAME_PLACEHOLDER/$INGRESS_NAME/g" "$INGRESS_FILE"
        sed -i "s/PREVIEW_DOMAIN_PLACEHOLDER/$PREVIEW_DOMAIN/g" "$INGRESS_FILE"
        sed -i "s/TLS_SECRET_PLACEHOLDER/$TLS_SECRET/g" "$INGRESS_FILE"
        sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" "$INGRESS_FILE"
        
        echo "✅ Updated all placeholders in ingress file"
      shell: bash

    - name: Apply Ingress YAML
      run: |
        INGRESS_FILE="${{ steps.ingress-name.outputs.ingress_file }}"
        INGRESS_NAME="${{ steps.ingress-name.outputs.ingress_name }}"
        echo "Applying ingress file $INGRESS_FILE to namespace ${{ inputs.namespace }}"
        kubectl apply -f "$INGRESS_FILE" -n ${{ inputs.namespace }}
        echo "✅ Ingress '$INGRESS_NAME' applied successfully for ${{ inputs.project-type }} project"
      shell: bash

    - name: Test AWS Route53 credentials
      if: inputs.aws-access-key-id != ''
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.aws-access-key-id }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.aws-secret-access-key }}
        AWS_DEFAULT_REGION: ${{ inputs.aws-region }}
      run: |
        echo "🔐 Testing AWS Route53 credentials..."
        echo "AWS Access Key ID: ${AWS_ACCESS_KEY_ID:0:8}..."  # Show first 8 chars for security
        echo "AWS Region: $AWS_DEFAULT_REGION"
        echo "Hosted Zone ID: ${{ inputs.aws-hosted-zone-id }}"
        
        # Test credentials
        CALLER_IDENTITY=$(aws sts get-caller-identity)
        echo "✅ AWS Identity: $(echo $CALLER_IDENTITY | jq -r '.Arn')"
        
        # Test Route53 access
        echo "Testing Route53 access..."
        aws route53 list-hosted-zones --query "HostedZones[?Id=='/hostedzone/${{ inputs.aws-hosted-zone-id }}'].Name" --output text
        
        echo "✅ Route53 access confirmed!"
      shell: bash

    - name: Wait for DNS propagation before certificate
      if: inputs.aws-access-key-id != ''
      run: |
        DOMAIN="${{ inputs.preview-domain }}"
        echo "🔍 Waiting for DNS propagation before certificate creation: $DOMAIN"
        
        # Install dig if not available
        if ! command -v dig &> /dev/null; then
          echo "Installing dnsutils for dig command..."
          sudo apt-get update && sudo apt-get install -y dnsutils
        fi
        
        # Wait for DNS to propagate before certificate creation
        for i in {1..30}; do
          RESOLVED_IP=$(dig +short "$DOMAIN" | head -1)
          if [ -n "$RESOLVED_IP" ]; then
            echo "✅ DNS is resolving: $DOMAIN -> $RESOLVED_IP"
            break
          fi
          echo "Attempt $i: DNS not propagating yet, waiting 10 seconds..."
          sleep 10
        done
        
        if [ -z "$RESOLVED_IP" ]; then
          echo "⚠️ DNS might still be propagating. Continuing anyway..."
        fi
      shell: bash

    - name: Get LoadBalancer IP and create DNS record
      if: inputs.aws-access-key-id != ''
      id: create-dns
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.aws-access-key-id }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.aws-secret-access-key }}
        AWS_DEFAULT_REGION: ${{ inputs.aws-region }}
      run: |
        INGRESS_NAME="${{ steps.ingress-name.outputs.ingress_name }}"
        NAMESPACE="${{ inputs.namespace }}"
        DOMAIN="${{ inputs.preview-domain }}"
        HOSTED_ZONE_ID="${{ inputs.aws-hosted-zone-id }}"
        
        echo "⏳ Waiting for LoadBalancer IP for: $INGRESS_NAME..."
        
        # Wait for LoadBalancer IP
        for i in {1..30}; do
          LB_IP=$(kubectl get ingress $INGRESS_NAME -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          if [ -n "$LB_IP" ]; then
            echo "✅ LoadBalancer IP found: $LB_IP"
            break
          fi
          echo "Attempt $i: LoadBalancer IP not ready yet, waiting 10 seconds..."
          sleep 10
        done
        
        if [ -z "$LB_IP" ]; then
          echo "❌ Failed to get LoadBalancer IP after 5 minutes"
          kubectl get ingress -n $NAMESPACE
          exit 1
        fi
        
        # Create Route53 DNS record
        echo "🌐 Creating DNS record: $DOMAIN -> $LB_IP"
        
        cat > route53-change.json << EOF
        {
          "Changes": [
            {
              "Action": "UPSERT",
              "ResourceRecordSet": {
                "Name": "$DOMAIN.",
                "Type": "A",
                "TTL": 300,
                "ResourceRecords": [
                  {
                    "Value": "$LB_IP"
                  }
                ]
              }
            }
          ]
        }
        EOF
        
        echo "Route53 change request:"
        cat route53-change.json
        
        # Create DNS record
        aws route53 change-resource-record-sets \
          --hosted-zone-id "$HOSTED_ZONE_ID" \
          --change-batch file://route53-change.json
        
        echo "✅ DNS record created successfully!"
        echo "🎉 Preview environment ready: https://$DOMAIN"
        echo "lb_ip=$LB_IP" >> $GITHUB_OUTPUT
      shell: bash

    - name: Wait for certificate issuance
      if: inputs.aws-access-key-id != ''
      run: |
        INGRESS_NAME="${{ steps.ingress-name.outputs.ingress_name }}"
        TLS_SECRET="${{ steps.ingress-name.outputs.tls_secret }}"
        NAMESPACE="${{ inputs.namespace }}"
        DOMAIN="${{ inputs.preview-domain }}"
        
        echo "⏳ Waiting for TLS certificate issuance..."
        echo "Certificate Secret: $TLS_SECRET"
        
        # Wait for certificate to be ready
        for i in {1..60}; do
          CERT_STATUS=$(kubectl get certificate $TLS_SECRET -n $NAMESPACE -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "Unknown")
          
          if [ "$CERT_STATUS" == "True" ]; then
            echo "✅ TLS Certificate is ready!"
            break
          elif [ "$CERT_STATUS" == "False" ]; then
            CERT_MESSAGE=$(kubectl get certificate $TLS_SECRET -n $NAMESPACE -o jsonpath='{.status.conditions[?(@.type=="Ready")].message}' 2>/dev/null || echo "No message")
            echo "❌ Certificate failed: $CERT_MESSAGE"
          fi
          
          echo "Attempt $i: Certificate status: $CERT_STATUS, waiting 10 seconds..."
          sleep 10
        done
        
        # Final check
        if kubectl get certificate $TLS_SECRET -n $NAMESPACE -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null | grep -q "True"; then
          echo "🎉 TLS Certificate is fully ready!"
          echo "🔒 Secure URL: https://$DOMAIN"
        else
          echo "⚠️ Certificate might still be issuing. Check with:"
          echo "kubectl get certificate $TLS_SECRET -n $NAMESPACE"
          echo "🔗 Preview URL: https://$DOMAIN (certificate pending)"
        fi
      shell: bash

    - name: Verify final setup
      if: inputs.aws-access-key-id != ''
      run: |
        INGRESS_NAME="${{ steps.ingress-name.outputs.ingress_name }}"
        TLS_SECRET="${{ steps.ingress-name.outputs.tls_secret }}"
        NAMESPACE="${{ inputs.namespace }}"
        DOMAIN="${{ inputs.preview-domain }}"
        
        echo "🔍 Final verification for branch: ${{ inputs.branch-name }}"
        echo "================================================"
        echo "🌐 Domain: https://$DOMAIN"
        echo "📦 Ingress: $INGRESS_NAME"
        echo "🔒 TLS Secret: $TLS_SECRET"
        echo "🏷️ Project: ${{ inputs.project-type }}"
        echo "================================================"
        
        # Show ingress status
        echo "Ingress Status:"
        kubectl get ingress $INGRESS_NAME -n $NAMESPACE -o wide
        
        # Show certificate status
        echo -e "\nCertificate Status:"
        kubectl get certificate $TLS_SECRET -n $NAMESPACE -o wide 2>/dev/null || echo "Certificate not found yet"
        
        echo -e "\n🎉 Preview environment deployment completed!"
        echo "📍 Your preview is available at: https://$DOMAIN"
      shell: bash
